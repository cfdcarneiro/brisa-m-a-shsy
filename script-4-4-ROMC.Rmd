---
title: "Meta-análises com ROMC"
author: "Clarissa F. D. Carneiro"
date: "2025-03-31"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
```

```{r warning=FALSE, results='hide'}
library(tidyverse)
library(metafor)
library(metaviz)
library(glmulti)
library(knitr)
```


```{r warning=FALSE}
load("dados_analise.R")
```

This script runs all analyses with effect size measures for ratios. 

Where the publications present a measure of variation for the control group, we are using the ROM (log transformed ratio of means) as the effect size measure, and in the cases where no variation is presented we are using ROMC (log transformed ratio of mean change), given sd control=0 and correlation = 0.

```{r}
dados_two_sample = dados_analise %>% filter(!is.na(control_sd)) %>% filter(control_sd!=0)

dados_one_sample = dados_analise %>% filter(is.na(control_sd)|control_sd==0)
```

```{r}
dados_two_sample_rom = escalc(measure = "ROM", m1i = as.numeric(treated_mean), m2i = as.numeric(control_mean), sd1i = as.numeric(treated_sd), sd2i = as.numeric(control_sd), n1i = as.numeric(treated_n), n2i = as.numeric(control_n), data = dados_two_sample)

dados_one_sample_romc = escalc(measure = "ROMC", m1i = as.numeric(treated_mean), m2i = as.numeric(control_mean), sd1i = as.numeric(treated_sd), sd2i = rep(0, nrow(dados_one_sample)), ni = as.numeric(treated_n), ri = rep(0, nrow(dados_one_sample)), data = dados_one_sample)

dados_meta_ratios = rbind(dados_two_sample_rom, dados_one_sample_romc)
```

# 2-level

```{r}
meta1 = rma(yi=yi, vi=vi, data = dados_meta_ratios, measure = "ROM", method = "REML", slab = rayyan.key)
summary(meta1)
confint(meta1)
```
Exact p value: `r meta1$pval`
Exact Q test p value `r meta1$QEp`

Effect (% of control): `r exp(meta1$b)`
CI.lb (%): `r exp(meta1$ci.lb)`
CI.ub (%): `r exp(meta1$ci.ub)`


Orchard Plot

```{r}
orchaRd::orchard_plot(meta1, group = "Comparison_ID", xlab = expression("Cell viability in the A"*beta ~ "group (% of control)"),
    transfm = "percent", k.pos = "left") + 
  scale_color_manual(values = "black") + 
  scale_fill_manual(values = "grey") + 
  scale_y_continuous(n.breaks = 20) + 
  theme(plot.margin = margin(0,10,0,0), text = element_text(size = 12)) + 
  geom_abline(intercept = 100, slope = 0, linetype = "longdash", color = "darkgreen", size = 0.70)

ggsave("./Figures/Fig-2B.png", width = 15, height = 8, units = "cm")
```

## Publication bias

Trim-and-fill

```{r}
meta_trimfill_R = trimfill(meta1, estimator = "R0", side = "right")
meta_trimfill_R
#Effect (% of control): 
exp(meta_trimfill_R$b)
#CI.lb (%): 
exp(meta_trimfill_R$ci.lb)
#CI.ub (%): 
exp(meta_trimfill_R$ci.ub)


meta_trimfill_L = trimfill(meta1, estimator = "L0", side = "right")
meta_trimfill_L

#Effect (% of control): 
exp(meta_trimfill_L$b)
#CI.lb (%): 
exp(meta_trimfill_L$ci.lb)
#CI.ub (%): 
exp(meta_trimfill_L$ci.ub)
```

Funnel plot

```{r}
ggplot(dados_meta_ratios, aes(x = 100*(exp(yi)), y = 1/sqrt(vi))) +
  geom_point(shape = 21, fill = "grey") + 
  scale_x_continuous(name = expression("Cell viability in the A"*beta ~ "group (% of control)"), n.breaks = 10) +
  scale_y_continuous(trans = "reverse", name = "1/SEM") +
  theme_classic() + 
  geom_vline(xintercept = 0, linetype="dashed", color = "grey") + 
  geom_vline(xintercept = 100*(exp(meta1$beta)), linetype="dashed", color = "darkgreen")

ggsave("./Figures/Fig-3.png")

```

```{r}
ggplot(dados_meta_ratios, aes(x = 100*(exp(yi)), y = 1/sqrt(mean_n))) +
  geom_point(shape = 21, fill = "grey") + 
  scale_x_continuous(name = expression("Cell viability in the A"*beta ~ "group (% of control)"), n.breaks = 10) +
  scale_y_continuous(trans = "reverse", name = expression(1/sqrt("Mean N"))) +
  theme_classic() + 
  geom_vline(xintercept = 0, linetype="dashed", color = "grey") + 
  geom_vline(xintercept = 100*(exp(meta1$beta)), linetype="dashed", color = "darkgreen")

ggsave("./Figures/Fig-3-altern.png")

```

```{r}
funnel.rma(meta1, yaxis = "seinv", pch = 1, pch.fill = 17)
```

Egger's regression

```{r}
regtest(x = meta1, ni = dados_meta_ratios$mean_n, predictor = "sqrtninv")
```

# 3-level

```{r}
meta2 = rma.mv(yi=yi, V=vi, data = dados_meta_ratios, method = "REML", random = ~1|rayyan.key/Comparison_ID)
meta2
confint(meta2)
```
Exact p value: `r meta2$pval`
Exact Q test p value `r meta2$QEp`

Effect (% of control): `r exp(meta2$b)`
CI.lb (%): `r exp(meta2$ci.lb)`
CI.ub (%): `r exp(meta2$ci.ub)`

```{r}
#As there is not function in the package metafor for estimating I^2 values for 3-level models, we imported the function from Mathias Harrer & David Daniel Ebert (https://raw.githubusercontent.com/MathiasHarrer/dmetar/master/R/mlm.variance.distribution.R)

mlm.variance.distribution = var.comp = function(x){

  m = x

  # Check class
  if (!(class(m)[1] %in% c("rma.mv", "rma"))){
    stop("x must be of class 'rma.mv'.")
  }

  # Check for three level model
  if (m$sigma2s != 2){
    stop("The model you provided does not seem to be a three-level model. This function can only be used for three-level models.")
  }

  # Check for right specification (nested model)
  if (sum(grepl("/", as.character(m$random[[1]]))) < 1){
    stop("Model must contain nested random effects. Did you use the '~ 1 | cluster/effect-within-cluster' notation in 'random'? See ?metafor::rma.mv for more details.")
  }

  # Get variance diagonal and calculate total variance
  n = m$k.eff
  vector.inv.var = 1/(diag(m$V))
  sum.inv.var = sum(vector.inv.var)
  sum.sq.inv.var = (sum.inv.var)^2
  vector.inv.var.sq = 1/(diag(m$V)^2)
  sum.inv.var.sq = sum(vector.inv.var.sq)
  num = (n-1)*sum.inv.var
  den = sum.sq.inv.var - sum.inv.var.sq
  est.samp.var = num/den

  # Calculate variance proportions
  level1=((est.samp.var)/(m$sigma2[1]+m$sigma2[2]+est.samp.var)*100)
  level2=((m$sigma2[2])/(m$sigma2[1]+m$sigma2[2]+est.samp.var)*100)
  level3=((m$sigma2[1])/(m$sigma2[1]+m$sigma2[2]+est.samp.var)*100)

  # Prepare df for return
  Level=c("Level 1", "Level 2 (exp)", "Level 3 (art)")
  Variance=c(level1, level2, level3)
  df.res=data.frame(Variance)
  colnames(df.res) = c("% of total variance")
  rownames(df.res) = Level
  I2 = c("---", round(Variance[2:3], 2))
  df.res = as.data.frame(cbind(df.res, I2))

  totalI2 = Variance[2] + Variance[3]


  # Generate plot
  df1 = data.frame("Level" = c("Sampling Error", "Total Heterogeneity"),
                  "Variance" = c(df.res[1,1], df.res[2,1]+df.res[3,1]),
                  "Type" = rep(1,2))

  df2 = data.frame("Level" = rownames(df.res),
                   "Variance" = df.res[,1],
                   "Type" = rep(2,3))

  df = as.data.frame(rbind(df1, df2))


  g = ggplot(df, aes(fill=Level, y=Variance, x=as.factor(Type))) +
    coord_cartesian(ylim = c(0,1), clip = "off") +
    geom_bar(stat="identity", position="fill", width = 1, color="black") +
    scale_y_continuous(labels = scales::percent)+
    theme(axis.title.x=element_blank(),
          axis.text.y = element_text(color="black"),
          axis.line.y = element_blank(),
          axis.title.y=element_blank(),
          axis.line.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.y = element_line(lineend = "round"),
          legend.position = "none",
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          legend.background = element_rect(linetype="solid",
                                           colour ="black"),
          legend.title = element_blank(),
          legend.key.size = unit(0.75,"cm"),
          axis.ticks.length=unit(.25, "cm"),
          plot.margin = unit(c(1,3,1,1), "lines")) +
    scale_fill_manual(values = c("darkseagreen3", "deepskyblue3", "darkseagreen2",
                                 "deepskyblue1", "deepskyblue2")) +

    # Add Annotation

    # Total Variance
    annotate("text", x = 1.5, y = 1.05,
             label = paste("Total Variance:",
                           round(m$sigma2[1]+m$sigma2[2]+est.samp.var, 3))) +

    # Sampling Error
    annotate("text", x = 1, y = (df[1,2]/2+df[2,2])/100,
             label = paste("Sampling Error Variance: \n", round(est.samp.var, 3)), size = 3) +

    # Total I2
    annotate("text", x = 1, y = ((df[2,2])/100)/2-0.02,
             label = bquote("Total"~italic(I)^2*":"~.(round(df[2,2],2))*"%"), size = 3) +
    annotate("text", x = 1, y = ((df[2,2])/100)/2+0.05,
             label = paste("Variance not attributable \n to sampling error: \n", round(m$sigma2[1]+m$sigma2[2],3)), size = 3) +

    # Level 1
    annotate("text", x = 2, y = (df[1,2]/2+df[2,2])/100, label = paste("Level 1: \n",
                                                                       round(df$Variance[3],2), "%", sep=""), size = 3) +

    # Level 2
    annotate("text", x = 2, y = (df[5,2]+(df[4,2]/2))/100,
             label = bquote(italic(I)[Level2]^2*":"~.(round(df[4,2],2))*"%"), size = 3) +

    # Level 3
    annotate("text", x = 2, y = (df[5,2]/2)/100,
             label = bquote(italic(I)[Level3]^2*":"~.(round(df[5,2],2))*"%"), size = 3)

  returnlist = list(results = df.res,
                    totalI2 = totalI2,
                    plot = g)
  class(returnlist) = c("mlm.variance.distribution", "list")

  invisible(returnlist)

  returnlist

}
```

```{r fig.keep='none', warning=FALSE}
mlm.variance.distribution(x = meta2)
```

### excluindo n de replicatas ou outras unidades nao independentes

```{r}
kable(dados_meta_ratios %>% count(n_definition))
dados_meta_ratios_independent = dados_meta_ratios %>% filter(
  n_definition=="independent determinations" | 
  n_definition=="independent experimental measurements" |
  n_definition=="independent experiments" |
  n_definition=="independent repetitions" |
  n_definition=="independent replicates" |
  n_definition=="independent runs" |
  n_definition=="independent sets of studies")
```

# Meta-regressions (3-level)

Differentiation

```{r}
dados_meta_ratios = dados_meta_ratios |> mutate(Diferentiation_method_YN = if_else(
  Diferentiation_method == "No differentiation",
  "No",
  "Yes"
))
```

Diff. duration

```{r}
dados_meta_ratios = dados_meta_ratios |> mutate(Diferentiation_duration_YN = if_else(
  Diferentiation_method_YN == "No",
  0,
  Diferentiation_duration_days
))

meta_difduration = rma.mv(yi=yi, V=vi, data = dados_meta_ratios, method = "REML", random = ~1|rayyan.key/Comparison_ID, mods = ~as.numeric(dados_meta_ratios$Diferentiation_duration_YN))

meta_difduration

mlm.variance.distribution(meta_difduration)

#pseudo R-squared
meta_difduration.R2 = (sum(meta2$sigma2)-sum(meta_difduration$sigma2))/sum(meta2$sigma2)*100
meta_difduration.R2 = if_else(meta_difduration.R2<0, 0, meta_difduration.R2)
```

Exact p value: `r meta_difduration$pval`
Exact Q test p value `r meta_difduration$QMp`
R^2: `r meta_difduration.R2`

intercept
Effect (% of control): `r exp(meta_difduration$b[1])`
CI.lb (%): `r exp(meta_difduration$ci.lb[1])`
CI.ub (%): `r exp(meta_difduration$ci.ub[1])`
moderator:
Effect (% of control): `r exp(meta_difduration$b[2])`
CI.lb (%): `r exp(meta_difduration$ci.lb[2])`
CI.ub (%): `r exp(meta_difduration$ci.ub[2])`


Diff. duration bubble plot

```{r}
fig_difduration_ = 
  ggplot(dados_meta_ratios, aes(x = as.numeric(Diferentiation_duration_YN), y=exp(yi), size = 1/sqrt(vi))) + 
  geom_point(shape = 21, fill = "grey", stroke = 0.5) + 
  labs(y = "Cell viability (% of control)", x = "Duration of differentiation (days)") + 
  theme_classic() + 
  scale_size_continuous(guide = "none") + 
  theme(legend.position = "bottom") + 
  scale_y_continuous(n.breaks = 7) + 
  scale_x_continuous(n.breaks = 7) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey")
fig_difduration_
ggsave("./Figures/Fig-4A.png", height = 10, width = 10, units = "cm")
```

Aggregation

```{r}
meta_aggregation = rma.mv(yi=yi, V=vi, data = dados_meta_ratios, method = "REML", random = ~1|rayyan.key/Comparison_ID, mods = ~relevel(factor(dados_meta_ratios$Abeta_aggregation), ref="Monomers"))

meta_aggregation

mlm.variance.distribution(meta_aggregation)

#pseudo R-squared
meta_aggregation.R2 = (sum(meta2$sigma2)-sum(meta_aggregation$sigma2))/sum(meta2$sigma2)*100
meta_aggregation.R2 = if_else(meta_aggregation.R2<0, 0, meta_aggregation.R2)
```

Exact p value: `r meta_aggregation$pval`
Exact Q test p value `r meta_aggregation$QMp`
R^2: `r meta_aggregation.R2`

intercept
Effect (% of control): `r exp(meta_aggregation$b[1])`
CI.lb (%): `r exp(meta_aggregation$ci.lb[1])`
CI.ub (%): `r exp(meta_aggregation$ci.ub[1])`
moderator/fibers:
Effect (% of control): `r exp(meta_aggregation$b[2])`
CI.lb (%): `r exp(meta_aggregation$ci.lb[2])`
CI.ub (%): `r exp(meta_aggregation$ci.ub[2])`
moderator/monomers:
Effect (% of control): `r exp(meta_aggregation$b[3])`
CI.lb (%): `r exp(meta_aggregation$ci.lb[3])`
CI.ub (%): `r exp(meta_aggregation$ci.ub[3])`
moderator/oligomers:
Effect (% of control): `r exp(meta_aggregation$b[4])`
CI.lb (%): `r exp(meta_aggregation$ci.lb[4])`
CI.ub (%): `r exp(meta_aggregation$ci.ub[4])`


Aggregation bubble plot

```{r}
fig_agregation_ = 
  ggplot(dados_meta_ratios, aes(x = Abeta_aggregation, y=exp(yi), size = 1/sqrt(vi))) + 
  geom_point(shape = 21, fill = "grey", position =  position_jitterdodge(dodge.width = 0), stroke = 0.5) + 
  labs(y = "Cell viability (% of control)", x = expression("A"*beta ~ "aggregation")) + 
  theme_classic() + 
  scale_size_continuous(guide = "none") + 
  theme(legend.position = "bottom") + 
  scale_y_continuous(n.breaks = 7) + 
  scale_x_discrete(limits = c("Monomers", "Oligomers", "Fibers", "Unclear")) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey")
  fig_agregation_
ggsave("./Figures/Fig-4B.png", height = 10, width = 10, units = "cm")
```

Abeta concentration (só até 100 uM)

```{r}
dados_meta_ratios_max100 = dados_meta_ratios %>% filter(Concentration_uM<100)

ggplot(dados_meta_ratios_max100, aes(x = Concentration_uM)) + 
  geom_histogram(fill = "grey", color = "black", binwidth = 1) + 
  labs(x = "Abeta concentration (uM)", y = "Count") + 
  theme_classic() + 
  theme(legend.position = "bottom") + 
  scale_x_continuous(n.breaks = 7) + 
  scale_y_continuous(n.breaks = 7)

ggsave("histograma-concentracao.png")
```

```{r}
meta_concent = rma.mv(yi=yi, V=vi, data = dados_meta_ratios_max100, method = "REML", random = ~1|rayyan.key/Comparison_ID, mods = ~dados_meta_ratios_max100$Concentration_uM)

meta_concent

mlm.variance.distribution(meta_concent)

#pseudo R-squared
meta_concent.R2 = (sum(meta2$sigma2)-sum(meta_concent$sigma2))/sum(meta2$sigma2)*100
meta_concent.R2 = if_else(meta_concent.R2<0, 0, meta_concent.R2)
```

Exact p value: `r meta_concent$pval`
Exact Q test p value `r meta_concent$QMp`
R^2: `r meta_concent.R2`

intercept
Effect (% of control): `r exp(meta_concent$b[1])`
CI.lb (%): `r exp(meta_concent$ci.lb[1])`
CI.ub (%): `r exp(meta_concent$ci.ub[1])`
moderator:
Effect (% of control): `r exp(meta_concent$b[2])`
CI.lb (%): `r exp(meta_concent$ci.lb[2])`
CI.ub (%): `r exp(meta_concent$ci.ub[2])`


Abeta concentration bubble plot

```{r}
fig_concent_ = 
  ggplot(dados_meta_ratios_max100, aes(x = Concentration_uM, y=exp(yi), size = 1/sqrt(vi))) + 
  geom_point(shape = 21, fill = "grey", stroke = 0.5) + 
  labs(y = "Cell viability (% of control)", x = expression("A"*beta ~ "concentration ("*mu*"M)")) + 
  theme_classic() + 
  scale_size_continuous(guide = "none") + 
  theme(legend.position = "bottom") + 
  scale_y_continuous(n.breaks = 7) + 
  scale_x_continuous(n.breaks = 7) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey")
fig_concent_
ggsave("./Figures/Fig-4C.png", height = 10, width = 10, units = "cm")

```

Abeta duration of exposure

```{r}
meta_duration = rma.mv(yi=yi, V=vi, data = dados_meta_ratios, method = "REML", random = ~1|rayyan.key/Comparison_ID, mods = ~as.numeric(dados_meta_ratios$Duration_days))

meta_duration

mlm.variance.distribution(meta_duration)

#pseudo R-squared
meta_duration.R2 = (sum(meta2$sigma2)-sum(meta_duration$sigma2))/sum(meta2$sigma2)*100
meta_duration.R2 = if_else(meta_duration.R2<0, 0, meta_duration.R2)
```

Exact p value: `r meta_duration$pval`
Exact Q test p value `r meta_duration$QMp`
R^2: `r meta_duration.R2`

intercept
Effect (% of control): `r exp(meta_duration$b[1])`
CI.lb (%): `r exp(meta_duration$ci.lb[1])`
CI.ub (%): `r exp(meta_duration$ci.ub[1])`
moderator:
Effect (% of control): `r exp(meta_duration$b[2])`
CI.lb (%): `r exp(meta_duration$ci.lb[2])`
CI.ub (%): `r exp(meta_duration$ci.ub[2])`

Abeta duration bubble plot

```{r}
fig_duration_ =
  ggplot(dados_meta_ratios, aes(x = as.numeric(Duration_days), y=exp(yi), size = 1/sqrt(vi))) + 
  geom_point(shape = 21, fill = "grey", stroke = 0.5) + 
  labs(y = "Cell viability (% of control)", x = expression("A"*beta ~ "duration of exposure (days)")) + 
  theme_classic() + 
  scale_size_continuous(guide = "none") + 
  theme(legend.position = "bottom") + 
  scale_y_continuous(n.breaks = 7) + 
  scale_x_continuous(n.breaks = 7) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey")
fig_duration_
ggsave("./Figures/Fig-4D.png", height = 10, width = 10, units = "cm")
```

Assay

```{r}
meta_assay = rma.mv(yi=yi, V=vi, data = dados_meta_ratios, method = "REML", random = ~1|rayyan.key/Comparison_ID, mods = ~relevel(factor(dados_meta_ratios$Assay), ref="MTT"))

meta_assay

mlm.variance.distribution(meta_assay)

#pseudo R-squared
meta_assay.R2 = (sum(meta2$sigma2)-sum(meta_assay$sigma2))/sum(meta2$sigma2)*100
meta_assay.R2 = if_else(meta_assay.R2<0, 0, meta_assay.R2)
```

Exact p value: `r meta_assay$pval`
Exact Q test p value `r meta_assay$QMp`
R^2: `r meta_assay.R2`

intercept
Effect (% of control): `r exp(meta_assay$b[1])`
CI.lb (%): `r exp(meta_assay$ci.lb[1])`
CI.ub (%): `r exp(meta_assay$ci.ub[1])`
moderator/cck-8:
Effect (% of control): `r exp(meta_assay$b[2])`
CI.lb (%): `r exp(meta_assay$ci.lb[2])`
CI.ub (%): `r exp(meta_assay$ci.ub[2])`
moderator/ez4u:
Effect (% of control): `r exp(meta_assay$b[3])`
CI.lb (%): `r exp(meta_assay$ci.lb[3])`
CI.ub (%): `r exp(meta_assay$ci.ub[3])`
moderator/mts:
Effect (% of control): `r exp(meta_assay$b[4])`
CI.lb (%): `r exp(meta_assay$ci.lb[4])`
CI.ub (%): `r exp(meta_assay$ci.ub[4])`
moderator/resazurin:
Effect (% of control): `r exp(meta_assay$b[5])`
CI.lb (%): `r exp(meta_assay$ci.lb[5])`
CI.ub (%): `r exp(meta_assay$ci.ub[5])`
moderator/wst:
Effect (% of control): `r exp(meta_assay$b[6])`
CI.lb (%): `r exp(meta_assay$ci.lb[6])`
CI.ub (%): `r exp(meta_assay$ci.ub[6])`
moderator/xtt:
Effect (% of control): `r exp(meta_assay$b[7])`
CI.lb (%): `r exp(meta_assay$ci.lb[7])`
CI.ub (%): `r exp(meta_assay$ci.ub[7])`

Assay bubble plot

```{r}
fig_assay_ = 
  ggplot(dados_meta_ratios, aes(x = Assay, y=exp(yi), size = 1/sqrt(vi))) + 
  geom_point(shape = 21, fill = "grey", position =  position_jitterdodge(dodge.width = 0), stroke = 0.5) + 
  labs(y = "Cell viability (% of control)", x = "Assay") + 
  theme_classic() + 
  scale_size_continuous(guide = "none") + 
  theme(legend.position = "bottom") + 
  scale_y_continuous(n.breaks = 7) + 
  scale_x_discrete(limits = c("MTT", "WST", "CCK-8", "MTS", "XTT", "Resazurin", "EZ4U")) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey")
fig_assay_
ggsave("./Figures/fig_assay-ratios-percent-change.png", height = 10, width = 10, units = "cm")
```

Cell density

```{r}
meta_density = rma.mv(yi=yi, V=vi, data = dados_meta_ratios, method = "REML", random = ~1|rayyan.key/Comparison_ID, mods = ~as.numeric(dados_meta_ratios$Cell_density))

meta_density

mlm.variance.distribution(meta_density)

#pseudo R-squared
meta_density.R2 = (sum(meta2$sigma2)-sum(meta_density$sigma2))/sum(meta2$sigma2)*100
meta_density.R2 = if_else(meta_density.R2<0, 0, meta_density.R2)
```

Exact p value: `r meta_density$pval`
Exact Q test p value `r meta_density$QMp`
R^2: `r meta_density.R2`

intercept
Effect (% of control): `r exp(meta_density$b[1])`
CI.lb (%): `r exp(meta_density$ci.lb[1])`
CI.ub (%): `r exp(meta_density$ci.ub[1])`
moderator:
Effect (% of control): `r exp(meta_density$b[2])`
CI.lb (%): `r exp(meta_density$ci.lb[2])`
CI.ub (%): `r exp(meta_density$ci.ub[2])`


Cell density bubble plot

```{r}
fig_density_ = 
  ggplot(dados_meta_ratios, aes(x = as.numeric(Cell_density), y=exp(yi), size = 1/sqrt(vi))) + 
  geom_point(shape = 21, fill = "grey", stroke = 1) + 
  labs(y = "Cell viability (% of control)", x = "Cell density (log10 scale)") + 
  theme_classic() + 
  scale_size_continuous(guide = "none") + 
  theme(legend.position = "bottom") + 
  scale_y_continuous(n.breaks = 7) + 
  scale_x_continuous(trans = "log10") + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey")
fig_density_
ggsave("./Figures/fig_density-ratios-percent-change.png", height = 10, width = 10, units = "cm")
```

Cell density x10^3

```{r}
dados_meta_ratios = dados_meta_ratios |> mutate(cell_density_1000 = Cell_density*(10^3))

meta_density = rma.mv(yi=yi, V=vi, data = dados_meta_ratios, method = "REML", random = ~1|rayyan.key/Comparison_ID, mods = ~as.numeric(dados_meta_ratios$cell_density_1000))

meta_density

mlm.variance.distribution(meta_density)
#pseudo R-squared
meta_density.R2 = (sum(meta2$sigma2)-sum(meta_density$sigma2))/sum(meta2$sigma2)*100
meta_density.R2 = if_else(meta_density.R2<0, 0, meta_density.R2)
```

Exact p value: `r meta_density$pval`
Exact Q test p value `r meta_density$QMp`
R^2: `r meta_density.R2`

intercept
Effect (% of control): `r exp(meta_density$b[1])`
CI.lb (%): `r exp(meta_density$ci.lb[1])`
CI.ub (%): `r exp(meta_density$ci.ub[1])`
moderator:
Effect (% of control): `r exp(meta_density$b[2])`
CI.lb (%): `r exp(meta_density$ci.lb[2])`
CI.ub (%): `r exp(meta_density$ci.ub[2])`


Cell density bubble plot

```{r}
fig_density_1000 = 
  ggplot(dados_meta_ratios, aes(x = as.numeric(cell_density_1000), y=exp(yi), size = 1/sqrt(vi))) + 
  geom_point(shape = 21, fill = "grey", stroke = 1) + 
  labs(y = "Cell viability (% of control)", x = "Cell density (log10 scale)") + 
  theme_classic() + 
  scale_size_continuous(guide = "none") + 
  theme(legend.position = "bottom") + 
  scale_y_continuous(n.breaks = 7) + 
  scale_x_continuous(trans = "log10") + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "grey")
fig_density_
ggsave("./Figures/fig_density-ratios-percent-change-1000.png", height = 10, width = 10, units = "cm")
```

# Multivariate Meta-regressions (3-level)

All combinations of variables from the selected list are tested in multivariable models, and the best models are ranked by corrected Akaike Information Criteria (AICc). For each best model selected, we decompose the R2 value for each moderator included. For this, we calculate the mean of the differences between R2 from models with and without the moderator in all possible orders of moderator inclusion. Additionally, we performed a Q test of moderators for each variable (including all dummy variables for each categorical moderator) to obtain p-values for individual variables.

```{r mv-functions}
rma.mv.glmulti <- function(formula, data, ...)
   rma.mv(formula, vi, data=data, method="ML", random = ~1|rayyan.key/Comparison_ID, verbose = FALSE, ...)
```

Functions to decompose R2 (3-level)

```{r}
# Create the list of all combinations of predictors for which you want to get R2 - returns the formula string, e.g. "~ a + b".
build_model_combinations = function (todos_preditores, preditor_interesse){
  outros_preditores = todos_preditores[todos_preditores != preditor_interesse]
  
  reduced_models = c("", map(1:length(outros_preditores), function (i) {
    paste0("~ ", apply(combn(outros_preditores, i), MARGIN = 2, paste0, collapse = " + "))
  }) |> unlist())
  
  full_models = map_chr(reduced_models, function (f) {
    if (f == "") {
      return (paste0("~ ", preditor_interesse) )
    } else {
      return (paste0(f, " + ", preditor_interesse) )
    }
  })
  
  list(full_models = full_models, reduced_models = reduced_models)
}

# Runs all models, full x reduced, from the formulas created above and calculates the difference between R2 values. 
all_model_comparisons_3a = function (comparison_list) {
  map2_dfr(comparison_list$reduced_models, comparison_list$full_models, function (m0s, m1s) {
    if (m0s == "") {
      m0 = rma(yi, vi, data=dat, method="ML", control = list(maxiter = 3000))
    } else {
      m0f = as.formula(m0s)
      m0 = rma.mv(yi, vi, random = ~1|rayyan.key/Comparison_ID, mods = m0f, data=dat, method="ML", control = list(maxiter = 3000))
    }
    
    m1f = as.formula(m1s)
    m1 = rma.mv(yi, vi, random = ~1|rayyan.key/Comparison_ID, mods = m1f, data=dat, method="ML", control = list(maxiter = 3000))
   
    m2 = rma.mv(yi=yi, V=vi, data = dat, method = "REML", random = ~1|rayyan.key/Comparison_ID, control = list(maxiter = 3000)) 
    
    reduced_model_size = length(all.vars(m1f)) - 1
    
    tibble(reduced = m0s, full = m1s, R2 = ((sum(m2$sigma2)-sum(m1$sigma2))/sum(m2$sigma2)*100)-((sum(m2$sigma2)-sum(m0$sigma2))/sum(m2$sigma2)*100), permutations = factorial(reduced_model_size))
  })
}

get_R2_for_single_predictor_3a = function (todos_preditores, preditor_interesse) {
  comparison_list = build_model_combinations(todos_preditores, preditor_interesse)
  
  r = all_model_comparisons_3a(comparison_list)
  s = mean(r$R2, na.rm = T)

  ws = weighted.mean(r$R2, r$permutations, na.rm = T)
  
  list(all_predictors = todos_preditores, predictor = preditor_interesse, results = r, mean = s, wmean = ws)
}

get_R2_for_all_predictors_3a = function (todos_preditores) {
  df = map(todos_preditores, function (preditor_interesse) {
    print(paste("Running models for", preditor_interesse))
    get_R2_for_single_predictor_3a(todos_preditores, preditor_interesse)
  })
  s = tibble(mean_R2 = map_dbl(df, "mean"), weighted_mean_R2 = map_dbl(df, "wmean"), predictor = map_chr(df, "predictor"))
  list(full_results = df, summary = s)
}
```

For the multivariate analyses, we can only use the comparisons for which all variables of interest are reported.

```{r}
dados_meta_ratios_max100$Abeta_aggregation = factor(dados_meta_ratios_max100$Abeta_aggregation, levels = c("Monomers", "Fibers", "Oligomers", "Unclear"))
                                       
dados_meta_ratios_max100$Assay = factor(dados_meta_ratios_max100$Assay, levels = c("MTT", "MTS", "WST"))

dados_uteis <- dados_meta_ratios_max100
dados_uteis <-  dados_uteis[!apply(dados_uteis[,c("Diferentiation_method", "Abeta_aggregation", "Assay", "Diferentiation_duration_days", "Concentration_uM", "Duration_days", "Cell_density")], 1, anyNA),]
```

Considering all pre-registered variables*, we'd have `r nrow(dados_uteis)` experiments available (i.e. `r nrow(dados_meta_ratios)-nrow(dados_uteis)` exclusions due to missing data). As we have 7 variables, we should have at least 70 comparisons - so can use all of them now. There are `r 2^7` possible models.

*c("Diferentiation_method", "Abeta_aggregation", "Assay", "Diferentiation_duration_days", "Concentration_uM", "Duration_days", "Cell_density")

```{r}
#multi_meta_reg <- glmulti(yi ~ Diferentiation_method + Abeta_aggregation + Assay + Diferentiation_duration_days + Concentration_uM + Duration_hours + Cell_density, data = dados_uteis, level=1, fitfunction=rma.mv.glmulti, crit="aicc", confsetsize=(2^7), plotty = F)
```

```{r}
#print(multi_meta_reg)
```
Top models (within 2 IC units of best model)
```{r}
#top <- weightable(multi_meta_reg)
#top <- top[top$aicc <= min(top$aicc) + 2,]
#top
```

Decomposing R2 for the best model:

```{r}
#dat = dados_uteis
#meus_preditores = c("Abeta_aggregation", "Diferentiation_method", "Assay")
#melhor_modelo = get_R2_for_all_predictors_3a(meus_preditores)

#melhor_modelo.summary = melhor_modelo$summary 

#melhor_modelo.summary = melhor_modelo.summary %>% mutate(pvalor=0)
#melhor_modelo.summary[1,4] = anova(multi_meta_reg@objects[[1]], btt = 2)$QMp
#melhor_modelo.summary[2,4] = anova(multi_meta_reg@objects[[1]], btt = 3)$QMp

```

Resultados:

```{r}
#multi_meta_reg@objects[[1]]
#confint(multi_meta_reg@objects[[1]])
#mlm.variance.distribution(multi_meta_reg@objects[[1]])
#Pseudo R2: 
#(sum(meta2$sigma2)-sum(multi_meta_reg@objects[[1]]$sigma2))/sum(meta2$sigma2)*100
```

```{r}
#dat = dados_uteis
#meus_preditores = c("Diferentiation_method", "Abeta_aggregation", "Assay", "Concentration_uM")
#melhor_modelo = get_R2_for_all_predictors_3a(meus_preditores)

#melhor_modelo.summary = melhor_modelo$summary 

#melhor_modelo.summary = melhor_modelo.summary %>% mutate(pvalor=0)
#melhor_modelo.summary[1,4] = anova(multi_meta_reg@objects[[2]], btt = 2)$QMp
#melhor_modelo.summary[2,4] = anova(multi_meta_reg@objects[[2]], btt = 3)$QMp
#melhor_modelo.summary[3,4] = anova(multi_meta_reg@objects[[2]], btt = 4)$QMp
#melhor_modelo.summary[4,4] = anova(multi_meta_reg@objects[[2]], btt = 5)$QMp
```

Resultados:

```{r}
#multi_meta_reg@objects[[2]]
#confint(multi_meta_reg@objects[[2]])
#mlm.variance.distribution(multi_meta_reg@objects[[2]])
#Pseudo R2: 
#(sum(meta2$sigma2)-sum(multi_meta_reg@objects[[2]]$sigma2))/sum(meta2$sigma2)*100
```


# Mudando diferenciação para sim/não, tirando Assay e duração da diferenciação
```{r}
dados_uteis2 <- dados_meta_ratios_max100
dados_uteis2 <-  dados_uteis2[!apply(dados_uteis2[,c("Diferentiation_method_YN", "Abeta_aggregation", "Concentration_uM", "Duration_days", "Cell_density")], 1, anyNA),]


#multi_meta_reg2 <- glmulti(yi ~ Diferentiation_method_YN + Abeta_aggregation + Concentration_uM + Duration_days + Cell_density, data = dados_uteis2, level=1, fitfunction=rma.mv.glmulti, crit="aicc", confsetsize=(2^5), plotty = F)
```

```{r}
#print(multi_meta_reg2)
```
Top models (within 2 IC units of best model)
```{r}
#top <- weightable(multi_meta_reg2)
#top <- top[top$aicc <= min(top$aicc) + 2,]
#top
```

Decomposing R2 for the best model:

```{r}
#dat = dados_uteis2
#meus_preditores = c( "Abeta_aggregation", "Concentration_uM", "Duration_days")
#melhor_modelo = get_R2_for_all_predictors_3a(meus_preditores)

#melhor_modelo.summary = melhor_modelo$summary 

#melhor_modelo.summary = melhor_modelo.summary %>% mutate(pvalor=0)
#melhor_modelo.summary[1,4] = anova(multi_meta_reg2@objects[[1]], btt = 2)$QMp
#melhor_modelo.summary[2,4] = anova(multi_meta_reg2@objects[[1]], btt = 3)$QMp
#melhor_modelo.summary[3,4] = anova(multi_meta_reg2@objects[[1]], btt = 4)$QMp
```

Resultados:

```{r}
#multi_meta_reg2@objects[[1]]
#confint(multi_meta_reg2@objects[[1]])
#mlm.variance.distribution(multi_meta_reg2@objects[[1]])
#Pseudo R2: 
#(sum(meta2$sigma2)-sum(multi_meta_reg2@objects[[1]]$sigma2))/sum(meta2$sigma2)*100
```

# Mudando diferenciação para sim/não, tirando Assay; duração da diferenciação igual a zero para não diferenciados
```{r}
dados_uteis3 <- dados_meta_ratios_max100
dados_uteis3 <- dados_uteis3 |> mutate(differentiation_duration_adjust = 
                                         if_else(Diferentiation_method_YN=="Yes",
                                                 Diferentiation_duration_days,
                                                 0))


dados_uteis3 <-  dados_uteis3[!apply(dados_uteis3[,c("Diferentiation_method_YN", "differentiation_duration_adjust", "Abeta_aggregation", "Concentration_uM", "Duration_days", "Cell_density")], 1, anyNA),]


multi_meta_reg3 <- glmulti(yi ~ Diferentiation_method_YN + differentiation_duration_adjust +  Abeta_aggregation + Concentration_uM + Duration_days + Cell_density, data = dados_uteis3, level=1, fitfunction=rma.mv.glmulti, crit="aicc", confsetsize=(2^6), plotty = F)
```

```{r}
print(multi_meta_reg3)
```
Top models (within 2 IC units of best model)
```{r}
top <- weightable(multi_meta_reg3)
top <- top[top$aicc <= min(top$aicc) + 2,]
top
```

Decomposing R2 for the best model:

```{r}
dat = dados_uteis3
meus_preditores = c("Abeta_aggregation", "Concentration_uM", "Duration_days")
melhor_modelo = get_R2_for_all_predictors_3a(meus_preditores)

melhor_modelo.summary = melhor_modelo$summary 

melhor_modelo.summary = melhor_modelo.summary %>% mutate(pvalor=0)
melhor_modelo.summary[1,4] = anova(multi_meta_reg3@objects[[1]], btt = 2)$QMp
melhor_modelo.summary[2,4] = anova(multi_meta_reg3@objects[[1]], btt = 3)$QMp
melhor_modelo.summary[3,4] = anova(multi_meta_reg3@objects[[1]], btt = 4)$QMp
```

Resultados:

```{r}
multi_meta_reg3@objects[[1]]
confint(multi_meta_reg3@objects[[1]])
mlm.variance.distribution(multi_meta_reg3@objects[[1]])

```

R2:
```{r}
#Pseudo R2: 
(sum(meta2$sigma2)-sum(multi_meta_reg3@objects[[1]]$sigma2))/sum(meta2$sigma2)*100
```

